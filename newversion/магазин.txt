Магазин выполнен как модуль, но на самом деле это группа модулей, объединенных в один.

Как водится, группа разделена разными установками и шаблонами.

Сам же модуль при инициализации проверяет, с какими настройками он вызван и подгружает соответствующий процесс.



Общий принцип работы

1. зависимость от других модулей и компонентов системы

Модуль спроектирован в тесном взаимодействии с контентом, на базе которого построен каталог, и формами.

Важно обратить внимание на то, что товары, даже отсутствующие в наличии, должны оставаться в базе контента, иначе информация по ним не сможет быть подтянута в заказ.

Если же вы не хотите выводить какие-то товары из каталога, можно предусмотреть в них поле, например, архив, и исключать контент по этому полю при выводе.

2. база данных

Этот модуль также имеет свою базу данных.

Можно было бы построить базу данных на основе полей пользователя. Однако, в таком случае, во-первых никто, кроме пользователя, не сможет получить информацию о заказах, а во-вторых, если хранить все заказы, то информация о пользователе станет слишком большой. Что касается первого пункта, заказы должны читать и отслеживать менеджеры и логистика. Если хранить их у пользователя, они могут получить доступ к другим его данным, что недопустимо с точки зрения безопасности. А насчет второго пункта, информация пользователя хранится в куках и в сессии, она превысит лимит кук и случится коллапс. Чтобы этого не произошло, куки придется чистить, а это дополнительная логика, трата ресурсов и времени, причем бесполезная.

В базе данных должна содержаться следующая информация:

	- номер / название / идентификатор заказа
	- дата составления заказа
	- текущее состояние
	- прочие промежуточные даты для отчетности - оприходование/проверка, оплата/предоплата (если есть), составление/сбор, отправление/передача в пункт/логистика, доставка/прибытие в пункт выдачи, получение (возможно, с оплатой), завершение
	- лог или информация о возникших ошибках, например, не прошла оплата, неверно указан адрес, не было доставлено, не было получено и т.д.
	- номер / название / идентификатор пользователя
	- данные о получателе - фио, email, контактный телефон, адрес доставки, вид оплаты, вид доставки, данные по карте (зашифрованные, если поддерживается сервисом оплаты)
	- данные об оплате
	- состав заказа - номер / название / идентификаторы товаров из каталога

3. защита информации

Отдельно нужно поговорить по поводу защиты информации о заказе от подделывания, в том числе информации о ценах в составе заказ и об оплате.

Значит, при формировании заказа в обработчик поступают только идентификаторы товара. Никакая другая информация, в том числе цена, не передается. Все необходимые данные о товарах в составе заказа собираются обработчиком заново. Таким образом, цена не передается через формы и таким способом ее невозможно подделать.

4. формирование цен, акции

При формировании цены идет учет следующих показателей:

	- общий массив заказа - a (array)
	- идентификатор товара - name
	- цена товара старая (обычная) - p (price)
	- цена товара новая (акционная) - pa (price action)
	- размер скидки по акции - sa (sale action)
	- размер скидки пользователя - su (sale user)
	- суммарная цена - pt (price total)
	- суммарная скидка - st (sale total)

Расчет зависит от следующих настроек:

	- скидки суммируются (opt = true) или не суммируются (opt = false)
	- минимально допустимая цена товара - pm (price min)
	- минимально допустимый размер скидки - sm (sale min)
	- скидка разрешена для всех пользователей или только для определенных групп (задаются по полю данных пользователя в формате "поле:значение")

Расчет идет по такой схеме:

	- если указана новая цена товара, то старая цена товара не учитывается,
	при этом предварительно высчитывается коэффициент скидки (sp - sale from price)
	он не будет задействован при расчете итоговой суммы, а нужен лишь для формул сравнения скидок
	if (!empty($pa)) { $sp = 100 - pa * 100 / p; $pt = $pa; } else { $sp = 0; $pt = $p; }
	
	- если указаны новая цена товара и размер скидки по акции, то вычисляется, что больше и этот параметр не учитывается,
	другими словами, работает только самая низкая цена, т.е. самая большая скидка
	if (!empty($sp) && !empty($sa)) { if ($sa < $sp) { $sa = 0; } else { $pa = 0; } }
	
	- если скидки не суммируются, то вычисляется самая большая скидка, и работает только она
	здесь то же самое - работает только самая низкая цена, т.е. самая большая скидка
	если же скидки суммируются, то вычисляется сумма всех скидок
	if (empty($opt)) { $st = ($sa > $su) ? $sa : $su; } else { $st = $sa + $su; }
	
	- если задан минимально допустимый размер скидки, то он сравнивается с итоговой скидкой и в случае необходимости срабатывает ограничение
	if (!empty($sm) && $st < $sm) { $st = $sm; }
	
	- высчитывается итоговая сумма товара
	$pt = round($pt * (1 - $st / 100), 2);
	
	- высчитывается итоговый показатель скидки
	$st = round(100 - $pt * 100 / $p);
	
	- если задана минимально допустимая цена товара, то она сравнивается с итоговой суммой и в случае необходимости срабатывает ограничение
	if (!empty($pm) && $pt < $pm) { $pt = $pm; }
	
	- итоговые данные записываются в массив, который затем записывается в общий массив, таким образом формируя массив заказа
	$a[$name] = ['p' => $p, 'pt' => $pt, 'st' => $st];

После того, как расчитана сумма каждого товара, расчитывается сумма заказа.

Здесь система предусматривает еще несколько дополнительных возможностей:

	- каждый n-ный товар по доп.скидке, либо по фикс.цене, с учетом того, что товары сортируются по цене
	- использование одноразового/многоразового/личного промокода на скидку, либо на определенную сумму
	- бесплатная доставка для определенной группы пользователей, 
	- добавление на выбор в качестве подарка ограниченного числа или любого числа на определенную сумму любых товаров или товаров из определенной группы

Промокоды хранятся в отдельной таблице

И здесь существуют новые показатели:

	- промокод на цену - pc (price code)
	- промокод на скидку - sc (sale code)

Расчет идет по такой схеме:

	- во-первых, товары сортируются по итоговой цене по убыванию
	array_multisort(array_column($a, 'pt'), SORT_DESC, SORT_NATURAL, $a);
	
	
	