Процессор - это обработчик процессов, который занимается проверкой входящих данных и их перераспределением

В файле 'processor.ini' перечисляются зарегистрированные в системе процессы и их обработчики (процессоры)

Например, для query=restore будет определен процесс "restore" и вызван обработчик "user"

Если включена константа DEFAULT_CUSTOM, то поиск процессора будет вестись также в кастомной папке, но только после обычной. Это сделано в целях безопасности.
Так что если хотите кастомизировать процессы, давайте им уникальные названия и обязательно регистрируйте через 'processor.ini'

Если будет вызван процесс, отсутствующий в списке или будет отсутствовать файл обработки процесса, то сайт вернет ошибку 403: неверный запрос

Пример структуры файла:

{
	"user" : ["restore", "activation", "deactivation"],
	"forms" : ["logout", "login", "registration", "editprofile", "changeavatar", "deleteavatar"],
	"projects" : ["createproject", "deleteproject", "openproject", "closeproject", "lockproject"],
	"editor" : ["savecard", "updatecard", "searchcard", "refreshcard", "saveboard"],
	"payment" : ["payment"]
}

Таким образом, в системе разрешены только запросы через $_GET['query'] или $_POST['query']

Стандартными параметрами являются статус $_GET/POST['status'] и данные или массив данных $_GET/POST['data']

Все эти данные будут собраны процессором в один системный объект $query со следующей структурой:

	name
		string
		имя запроса, так же название процесса
	param
		string
		параметр запроса, чаще всего это параметр модуля, с которым он был вызван
	status
		string
		статус запроса, например для платежа это может быть fail - ошибка и success - успешно
		будьте внимательны (!) если задан статус, то обработчик будет пытаться загрузить процессор с таким же именем
	hash
		string
		хэш запроса, собственно это время, закриптованное базовой функцией для проверки времени запроса
		время жизни запроса устанавливается константой SECURE_QUERYTIME
		если время запроса было больше, чем время его жизни (например, более 10 минут назад), то запрос считается устаревшим и система выдаст ошибку
		для тестирования запросов можно использовать фейковый запрос, состоящий из 10 любых знаков и символа '=' вначале, например '=1234567890' или '=qwertyuiop',
		но это работает только в режиме разработки
	data
		array
		массив сопутствующих данных
		передается через $_POST/GET['data'], например:
		$_POST['data']['name'], $_POST['data']['password'], $_POST['data']['email']
	open
		string
		адрес вызываемого процессора
		формируется в обработчике
	close
		true/false
		прервать дальнейшую загрузку сайта после вызова данного процесса или нет, особенно полезен при ajax запросах
		назначается через $_POST/GET['close']
		будьте внимательны (!) любое непустое значение обрабатывается как true, любое пустое значение, а также 0 или отсутствие обрабатывается как false
	method
		string
		метод передачи данных - post или get, причем всегда маленькими буквами, т.к. при получении, значение метода конвертируется в маленькие буквы
	errors
		array
		массив, содержащий ошибки
	var
		array
		массив переменных, необходимых для обработки данных процессором
		по окончании обработки он чистится, так что если нужно сохранить какие-либо данные, передавайте их либо через data, либо через errors

Базовый шаблон модуля форм формирует правильный запрос с хэшем и всеми данными

Данные из строки в любом случае преобразуются в массив с ключом 'default': ...&data=text >>>>>>>> $query -> data['default'] => 'text'
Чтобы передать массив данных, например ['id' => 1, 'name' => 'user', 'type' => 'description'] он должен выглядеть так: ...&data[id]=1&data[name]=user&data[type]=description

Что еще важно - name и status подвергаются обработке и по-сути являются безопасными. Однако data обработке не подвергается, и может содержать в себе все, что угодно.
Поэтому в процессоре важно будет обрабатывать получаемые данные, сравнивать их с допустимыми и отбрасывать лишние

Процессор - вызываемый обработчик того или иного события (процесса), например, регистрации или авторизации пользователя, отправки сообщений и т.п.

Обшие процессы собраны в одну группу и ими по-сути должен заниматься один процессор. Но на данный момент это не так.
В этой версии процессор, грубо говоря, представляет собой название папки, в которой содержится набор процессоров, каждый из которых заточен только под одно событие

Введение переменной $query позволяет упорядочить поток входящих данных и в дальнейшем стандартизировать и укрепить систему процессов



Для работы с модулями была введена приоритетная проверка процессов.

Это сделано для того, чтобы во-первых, изолировать процессы модуля от процессов системы.
А во-вторых, если злоумышленник попывается взломать системный процесс через модуль, то ему будет до него труднее добраться.
Аргумент, конечно, слабый, но тем не менее он есть.

Как работает приоритет. Все просто - если $query -> name соответствует названию модуля, а также если в модуле есть файл
обработчика query.php, то процессор переключает обработку на него.



Формы, соответственно, должны выглядеть так:

<form method="post" id="form"> // или get - неважно
								// идентификатор формы необходимо указывать, если вы хотите связать с этой формой вынесенные за ее пределы элементы
								// например, тэг button после закрытия формы
	<input type="hidden" name="query" value="process"> // здесь в value указать название процесса или модуля
	
	<input type="text" name="data[...]" value="..."> // дальше идут строки формы, где любые данные передаются через массив data, иначе они просто не будут учтены
	...
	
	<input type="submit" value="submit"> // кнопка отправки данных на сервер
	<button type="submit">button name</button> // или так
	<button type="submit" name="data[...]">button name</button> // если добавить атрибут name, то с помощью этой кнопки можно также передать еще одни данные
</form>

<input type="text" form="form" name="data[...]" value="..."> // данные из этого поля также будут отправлены на сервер, т.к. поле связано через атрибут form с id формы
<button type="submit" form="form">button name</button> // эта кнопка также отправит данные формы на сервер, т.к. она связана через атрибут form с id формы
